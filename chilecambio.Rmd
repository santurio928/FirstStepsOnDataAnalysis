---
title: "Untitled"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.path='Figs/')
```

# Análisis descriptivo datos Chile
Comenzaremos con el análisis descriptivo para los datos de "Chile" del paquete "car" analizando cada una de las variables, y el  dataframe en general.Primero cargaremos las librerías que vamos a necesitar. El objetivo mas adelante será la predicción de voto de las personas que en la encuesta contestaron que estaban indecisos, o de los que no había datos(NA).

Lo primero que haremos será cargar los paquetes que vamos a necesitar.
```{r}
library(car)#para los datos de Chile
library(tidyverse)
library(ggplot2)
library(RcmdrMisc)
library(hunspell)
library(caret)
```
Después cargaremos los datos, utilizamos data() para cargar los datos de un paquete. Al ser Chile unos datos de una librería ?Chile nos mostrará la descripción del dataset y las variables, veremos el nombre de las variables y una pequeña descripción.
```{r}
data(Chile)
```
Chile es un dataframe que tiene 2700 filas(2700 encuestados) y 8 columnas( cada encuestado ha dado información sobre 8 variables) de una encuesta realizada en Chile en 1988 para una votación sobre Pinochet.

Una vez cargado los datos names() nos dira el nombre de las variables, y class() que tipo de objeto es, en este caso un dataframe con las variables region, population, sex, age, education, income, statusquo y vote.
```{r}
names(Chile)
class(Chile)
```
Cada variable puede ser distinta para saber que tipo de variable es podemos hacer class() a la variable, si esta es factor podremos hacer levels() para saber sus niveles.

Otra opción es hacer str() en lugar de class() lo que nos dará mas detalles de la  estructura de la variable directamente.

## Análisis univariante 
Comenzamos ahora el análisis univariante, creo que lo mejor seria hacer un summary() de cada una de las variables ya que este va a diferenciar el análisis entre las variables según estas sean variables cuantitativas o cualitariva.

### Región
Es un factor, una variable cualitativa que tiene los siguientes niveles C(Central), M(area metropolitana de Santiago), N(Norte), S(Sur), SA(ciudad de Santiago)
```{r}
class(Chile$region)
levels(Chile$region)
```
Para región que es una variable categórica podemos ver las frecuencias absolutas de sus niveles,  vemos que el valor C se repite 600 veces el valor M 100 el N 322  el S 718 y el SA 960. 

Para ver las frecuencias relativas podemos hacer una tabla,table(), y dividirla entre el número de columnas multiplicado por 100, esto nos dará el porcentaje de cada uno de los niveles del factor.
```{r}
summary(Chile$region)
table(Chile$region)/nrow(Chile)*100

```
Para visualizar esto podemos hacer un diagrama de barras. La función plot() por defecto hace un diagrama de barras, 
```{r}
plot(Chile$region)
```
Para saber si la variable contiene NA podemos meter la variable en la función 
is.na() esto nos devolverá un vector lógico de TRUE y FALSE para cada valor de la variable. La función any nos dirá si algún valor de ese vector es TRUE, de ser así la función any nos devolverá TRUE de lo contrario nos devolverá FALSE.
```{r}
any(is.na(Chile$region))
```
FALSE, la variable no tiene NA´s.

### Population
La siguiente variable es un integer, una variable cuantitativa que toma números enteros, en principio una variable continua de la  población de la comunidad correspondiente. Vamos ha hacer un summary para ver sus estadísticos descriptivos.
```{r}
class(Chile$population)
summary(Chile$population)
```
La variable tiene de mínimo 3750 y max 250000, su media es  15222 el primer cuartil 25000 y el tercero es 250000 igual  que el máximo.

vamos a ver su histograma con la función hist() vemos como se distribuye.
```{r}
hist(Chile$population)
```
El histograma nos muestra que en lugar de ser una variable continua son los mismos valores que se repiten varias veces, es una variable discreta, vamos a hacer una tabla de frecuencias.
```{r}
table(Chile$population)/nrow(Chile)*100
```
En efecto, parece que no hay muchos valores, si metemos la tabla en la función length() nos dara su longitud, es decir el numero de valores distintos.
```{r}
length(table(Chile$population))
any(is.na(Chile$population))
```
Parece que hay 10 valores que se repiten, esto se deberá a que se ha preguntado en 10 comunidades y esa es la población que se repite, vemos que la población con 250000 habitantes tiene hasta el 48% de los encuestados(Conclusión extraída de la tabla). Si fuera necesario, esta variable podría pasarse a categórica ya que solo tiene 10 registros distintos.Parece que no hay NA´s.

Al ser una variable discreta podemos hacer mejor un gráfico de barras. pero al ser una variable cuantitativa pasaremos la variable a factor con as.factor()
```{r}
plot(as.factor(Chile$population))
```
Podemos observar visualmente ese 48% de los registros que se tomaron en la ciudad de 250000 habitantes.
### Sex
Es un factor con los niveles F para femenino y M para masculino
```{r}
class(Chile$sex)
levels(Chile$sex)
summary(Chile$sex)

```
Como es un factor vamos a hacer una tabla para ver las frecuencias absolutas y relativas, 
```{r}
table(Chile$sex)
table(Chile$sex)/nrow(Chile)*100
any(is.na(Chile$sex))
```
Hay 1379(51.07%) mujeres y 1321(48.92%) hombres el gráfico de barras muostrará perfectamente el resultado. No hay NA´s.
```{r}
plot(Chile$sex)
```
Representación visual de los datos, hay un poco mas de registros de mujeres.

### Age
La edad en años es un integer, toma valores enteros con la edad de las personas, sabemos que es una variable cuantitativa pero no si es discreta o continua. Vamos a hacer un summary() para ver los estadísticos descriptivos.
```{r}
class(Chile$age)
summary(Chile$age)
```
El mínimo es 18(La mayoría de edad) y el máximo 70, el primer cuartil 26 y el tercero 49, la media es 38.55 y la mediana 36.
Podemos ver que hay un NA.
```{r}
hist(Chile$age)
length(table(Chile$age))
```
Podemos observar como se distribuye en el histograma, en este caso observaremos que no hay saltos, toma todos  los valores entre 18 y 70. En este caso podríamos complementar el análisis con un gráfico de cajas con la función boxplot()
```{r}
boxplot(Chile$age)
```
 Podemos ver los cuartiles, el recorrido intercuartilico y la mediana, parece que esta algo desviada hacia los valores menores, la mitad de los registros están entre gente de 18 y 36 años.

### Education
Factor con los niveles, P para educación primaria, PS para niveles de educación post secundaria y S para niveles de educación secundaria.

```{r}
class(Chile$education)
levels(Chile$education)
summary(Chile$education)
table(Chile$education)/nrow(Chile)*100
```
El valor que mas se repite es S 1120 veces(41.48%), seguido de P 1107 (41%) y de PS 462 (17.11%), también hay 11 NA´s.

Podemos ayudar a la visualización con un gráfico de barras.
```{r}
plot(Chile$education)
```
### Income
Integer que es una variable que toma valores enteros,es cuantitativa, en principio parece una variable continua que expresa los ingresos mensuales en pesos. Vamos a ver los estadísticos principales.
```{r}
class(Chile$income)
summary(Chile$income)
```
Podemos mirar la longitud de la tabla de frecuencias para ver si realmente es una variable continua, también podemos ver el histograma. Hay 98 NA´s.
```{r}
hist(Chile$income)
```
De nuevo es una variable que parecia continua pero que realmente tiene 7 valores distintos.
```{r}
length(table(Chile$income))
```
Esto se debe a que en la encuesta debieron dar una horquilla de ingresos.Podemos ver un gráfico de barras para ver los valores y su frecuencia, pero al ser cuantitativa la función plot no nos hará un gráfico de barras, por eso es mejor pasarlo a factor con la función as factor.
```{r}
plot(as.factor(Chile$income))
```
Hay siete tipos distintos de ingresos(2500,7500,15000,35000,75000,125000,200,000), siguen prácticamente una distribucion normal un poco desviada hacia valores bajos.
```{r}
table(Chile$income)/nrow(Chile)*100
```
Podemos ver que los ingresos que mas se repiten son 15000 con un28% y 35000 con un 27%.

### Statusquo
Escala de apoyo al status-quo, es una variable numeric, numérica, pero no necesariamente números enteros que toma valores en función del apoyo al status-quo. Podemos ver sus estadlísticos principales.
```{r}
class(Chile$statusquo)
summary(Chile$statusquo)
length(table(Chile$statusquo))

```
 Bueno, esta variable ya no toma unos pocos valores, si no que tiene hasta 2092 valores distintos, toma valores negativos con un mínimo de 1.80301 y un máximo de 2.04859 la media es 0 la mediana -0.04558 el primer cuartil -1.00223 y el tercero 0.96857. Tiene 17 NA´s.
 Pata ver su distribución podemos hacer un histograma.
```{r}
hist(Chile$statusquo)
```
 O un gráfico de cajas.
```{r}
boxplot(Chile$statusquo)
```
Esta variable al ser continua se puede ver los datos perfectamente en el gráfico boxplot los curtiles y la media.
 
 la media es 0 pero la mediana -0.04558 por eso aunque el valor medio sea 0 hay mas registros por debajo del 0 que por encima.
### Vote

  Nuestra variable a predecir, es una variable factor según lo que van a votar en relación a Pinochet, con los niveles A para abstención, N para no(contra Pinochet), Y para si , U para indeciso.
```{r}
class(Chile$vote)
levels(Chile$vote)
summary(Chile$vote)
table(Chile$vote)/nrow(Chile)*100

```
 El valor que mas se repite es N 889(32.92592%) el segundo Y 868(32.1481%) después U 588(21.7%) por último A 187(6.92%) y también hay 168 NA´s. esta distribución se puede ver perfectamente en el gráfico de barras.
```{r}
plot(Chile$vote)
```
 

## Análisis bivariante 
Una vez ya conocemos cada variable, si es factor, si no, si podría convertirse a factor o si no, vamos a comenzar el análisis bivariante.

El objetivo es predecir lo que votarán los indecisos o aquellos que no contestaron(NA) pero los que se abstendrán vote=A no nos sirven. Por eso vamos a eliminarlos de nuestro dataset.

Por otro lado si queremos predecir a partir del resto de las variables lo que votarán los que hayan contesrado U o sean NA´s, será importante eliminar aquellos encuestados de los que no se tengán datos en las variables predicadoras, es decir tengan NA´s en cualquier variable que no sea vote.

Utilizaremos ahora lenguaje del paquete tidyverse, nomenclatura a través de pipes que incluye como el primer elemento de una función aquel objeto que esta a la izquierda de la tubería %>%.

ademas utilizaremos drop_na para eliminar los na de las 7 primeras columnas.
```{r}
nrow(Chile)
Chile<-Chile%>%drop_na(1:7)
nrow(Chile)
2700-nrow(Chile)
any(is.na(Chile[1:7]))
any(is.na(Chile[8]))
```
Ahora tengo 2581 filas es decir, 2581 datos para cada variable, pero no tengo NA´s salvo en la variable a predecir, he borrado 119 datos. solo tengo NA´s en la variable a predecir

Tampoco tengo interés en la gente que se abstendrá ya que se me pide predecir que votaran los que estan indecisos ("U") y los que no hay registro NA.

```{r}
summary(Chile$vote)
```
Tras haber quitado los NA del resto de variables hay 177 que contestaron A en vote, voy a eliminarlos.
```{r}
Chile<-Chile%>%filter(vote!="A"| is.na(vote))
summary(Chile$vote)
nrow(Chile)
Chile$vote<-droplevels(Chile$vote)
summary(Chile$vote)
```
Ahora tengo 2404 registros para cada variables, pero nadie que haya contestado A, tambien hago un droplevels ya que no necesito el nivel A nunca mas.

Me dispongo ahora si a relacionar variable a variable, como la variable a predecir es vote, no tiene sentido para este problema relacionar por ejemplo income con statusquo así que voy a relacionar cada variable con vote.

### Región
Al ser dos variables cualitativas vamos a ver la tabla de frecuencia y la de frecuencia relativas, para ver como se relaciona la región con el voto
```{r}
table (Chile[c("region","vote")])
prop.table (table (Chile[c("region","vote")]), "region")
```
Según la región hay entre un 16% y un 27,5% de indecisos, pero para ver si la region puede tener que ver con votar Y o N vamos a quitarlos.
```{r}
prop.table (table (Chile[Chile$vote!="U",c("region","vote")]), "region")
```
El porcentaje de los que votan si cambia del 41% al 68% según la región, podemos hacer un contraste chi-cuadrado, la hipótesis nulas seria la independencia de los factores, podemos excluir U.

```{r}
ChileYN<-Chile %>% filter(Chile$vote!="U") 
ChileYN$vote<-droplevels(ChileYN$vote)
table1<-xtabs(~region+vote,data=ChileYN)
chisq.test(table1)
```
El p-valor es <0.05 rechazo la Ho de independencia,sin embargo vamos a mirar la tabla.
```{r}
table1
```
Para la región M hay mas del doble que votan Y que N pero solo hay 17 y 37 registros, eso puede alterar el test

En problemas así visualizar puede ayudar, al tratarse de 2 variables cualitativas erigiré el stack bar chart o gráfico de barras apiladas, y tras observarlo parece que no hay nada concluyente, puede que sea cierto que en algunas regiones se tienda mas a un voto u a otro, pero no me parece algo a través de lo cual yo haria una predicción.
```{r}
ggplot(ChileYN, aes(x = region)) + 
  geom_bar(position = "stack")+
    facet_wrap(~vote)
```
### Population
Population  es una variable cuantitativa discreta por lo que su análisis podria hacerse de manera parecida a un análisis de dos variables cualitativas.
```{r}
table (ChileYN[c("population","vote")])
prop.table (table (ChileYN[c("population","vote")]), "population")
```
Por ejemplo en la ciudad de 3750 habitantes el 61% votaran que si y en la de 8750 el 75% sin embargo en las ciudades grandes se tiende mas al no, en la de 250000 hab es un 60% el no.

Vamos a visualizarlo
```{r}
ggplot(ChileYN, aes(x = population)) + 
  geom_bar(position = "stack")+
    facet_wrap(~vote)
```
Las conclusiones que saco es que parece que sigue el mismo patrón, seguramente si paso las variable población a factor y hago el test de independencia concluya que no son independientes, pero no creo que sea una variable que se utilice para predecir.
```{r}
table2<-xtabs(~as.factor(population)+vote,data=ChileYN)
chisq.test(table2)
```
En efecto rechazo que las variables sean independientes, porque si hay relación pero puede que no sea la mejor variable para la predicción.

### Sex
Estamos de nuevo ante dos variables categóricas, vamos a hacer las tablas de frecuencia absoluta y relativa
```{r}
table (ChileYN[c("sex","vote")])
prop.table (table (ChileYN[c("sex","vote")]), "sex")
```
Parece observarse que los hombres son mas partidarios del N y las mujeres de Y vamos a visualizarlo

```{r}
ggplot(ChileYN, aes(x = sex)) + 
  geom_bar(position = "stack")+
    facet_wrap(~vote)
```
Los hombres tienden mas al No y las mujeres mas al Sí seguro que no son variables independientes, pero hasta cuanto me ayudará a la predicción.
```{r}
table3<-xtabs(~sex+vote,data=ChileYN)
chisq.test(table3)
```
En efecto, las variables no son independientes.
### Age
Vamos con nuestra primera variable cuantitiativa continua, en casos de tener una variable cuantitativa y una cualitativa podemos empezar por representar un gráfico boxplot.

```{r}
boxplot (age ~ vote, ChileYN)
```
Pude observarse que los jovenes tienden mas al no y los mayores mas al Si, además entre los jovenes hay menos dispersion, el recorrido intercuartilico es menor, entre los mayores hay mas dispersión. Pero tampoco parece ser algo muy determinante. Si hago unas gráficas de densidad de kernel agrupadas puedo ver como no parece muy determinante la edad.
```{r}
ggplot(ChileYN, aes(x = age)) +
  geom_density(alpha = 0.4) +
  labs(title = "Voto según edad")+
    facet_wrap(~vote)
```
No parece que sea algo muy determinante, pero si que se observa una tendencia de los jovenes hacia el no y de los adultos hacia el si.
Podemos hacer un numSummary() de la edad agrupada en función del voto para ver su media su desviación tipica y otros estadísticos descriptivos
```{r}
numSummary(ChileYN$age,groups=ChileYN$vote)
```
También podemos hacer un test  t-student para contrastar la Ho de igualdad de medias.
```{r}
t.test(age~vote, alternative='two.sided', conf.level=.95, var.equal=FALSE, 
  data=ChileYN)
```
el p valor < 0.05 por lo que rechazo la Ho  de igualdad de medias, esto significa que la media de edad según el voto es distinta por lo que las variables estan relacionadas. Pero no se hasta cuando me ayudará a predecir.

### Education
Otra vez dos variables cualitativas, vamos a seguir el mismo procedimiento.
```{r}
table (ChileYN[c("education","vote")])
prop.table (table (ChileYN[c("education","vote")]), "education")

```
Puede parecer que hay una tendencia, que la gente con educación secundaria y postsecundaria  tiende mucho mas a el NO  mientras que los de educción primaria tienden al Si. Vamos a visualizar los datos.
```{r}
ggplot(ChileYN, aes(x = education)) + 
  geom_bar(position = "stack")+
    facet_wrap(~vote)
```
En efecto parece que se cumple esa tendencia, pero podemos hacer un contraste chi cuadrado para comprobarlo
```{r}
table3<-xtabs(~education+vote,data=ChileYN)
chisq.test(table3)
```
p valor < 0.05 rechazo la Ho de que las variabels son independientes por lo que tienen relación.
### Income
Income es una variable que parecia continua pero es discreta. Se podría convertir a factor
```{r}
table (ChileYN[c("income","vote")])
prop.table (table (ChileYN[c("income","vote")]), "income")
```
Al hacer la tabla de frecuencia se observa que el N y el Y estan entre el 45% y el 55% para todos los niveles de ingresos, vamos a representarlo.
```{r}
ggplot(ChileYN, aes(x = income)) + 
  geom_bar(position = "stack")+
    facet_wrap(~vote)
```
Aunque parece seguir el mismo patrón este gráfico no me parece muy bueno. vamos a pasar income a factor y hacer un test chi cuadrado
```{r}
table4<-xtabs(~as.factor(income)+vote,data=ChileYN)
chisq.test(table4)
```
 El p valor es > que 0.05 no rechazo la Ho nula de que las variables son independientes, es decir, que posiblemente sea la variable que menos me ayude a estimar.
 
 Otra opción con dos variables categóricas(al pasar income a factor podriamos observarla como categórica, con 7 grupos de ingresos distintos) es hacer gráficos de mosaico.
```{r}
vcd::mosaic(table4, main = "Ingresos en función del voto")
```
 Podemos contrastar lo que ya nos dijo el test Chi-cuadrado, al ser del mismo tamaño los cuadros significa que hay prácticamente el mismo tamaño de población que vota Y con un ingreso determinado al que vota N.

### Statusquo
Tenemos ahora una variabe continua contra una categórica, vamos a ver los estadísticos descriptivos agrupados.
```{r}
numSummary(ChileYN$statusquo,groups=ChileYN$vote)
```
Se observa una diferencia enorme, la media de los que votan N es de -0.91 mientras la de los que votan Y es de 0.93

En estos casos conviene empezar con un gráfico boxplot para apreciar la diferencia.
```{r}
boxplot (statusquo ~ vote, ChileYN)
```
Este gráfico me parece muy relevante, los que votan no suelen tener poco statusquo salvo algunos outlier, los que votan si un statusquo muy elevado salvo algunos outlier, y los indecisos tienen un statusquo que se situa en la media.voy a hacer unas gráficas de densidad de kernel agrupadas.
```{r}
graficopredicion<-ggplot(ChileYN, aes(x = statusquo)) +
  geom_density(alpha = 0.4) +
  labs(title = "Voto según statusquo")+
    facet_wrap(~vote);graficopredicion
```
Parece evidente, a mayor statusquo mayor probabilidad de votar si y a menor statusquo mayor probabilidad de votar no. Vamos hacer un test T de student para contrastar la H0 de igualdad de medias.
```{r}
t.test(statusquo~vote, alternative='two.sided', conf.level=.95, var.equal=FALSE, 
  data=ChileYN)
```
P valor < 0.05 rechazo H0 de igualdad de medias, las variables no son independientes, algo que parecia evidente tras su visualización.
El statusquo es la variable que mejor me clasificará el voto con los datos observados

## Conclusiones

Parece ser que el status-quo es lo mas relevante, así que predecirla los votos faltan tes en función del statusquo, los que no pueda predecir por el statusquo deberé predecirlos según la educación o el sexo que eran las otras variables relevantes.

Podemos hacer un modelo muy simple, una regresión logistica(logic) ya que tenemos una variable a predecir cualitativa y variables predicadoras cualitativas y cuantitativas.
```{r}
modelologit<- glm(vote ~ statusquo + sex + region + population + income + education + age, family=binomial(logit), data=ChileYN)
summary(modelologit)
```
Si hacemos un resumen de modelo podemos ver que las únicas variables que considera significativas son el statusquo el sexo y la educación, lo que concuerda con la información que nosotros percibimos en el análisis descriptivo.

## Predicciones

Con las conclusiones obtenidas y debido a la naturaleza del problema( predecir variable categóricas con variables continuas y categóricas) se podría predecir de diversas maneras, con el mismo logit, con algoritmos de arboles de decisión maquinas vector soporte etc..

Podríamos imputar los datos según nuestro análisis descriptivo para seguir con la linea del trabajo. Vamos a volver a ver el gráfico de statusquo
```{r}
graficopredicion
```

Podemos ver que las personas que votan si con un statusquo<0 son casi nulas.
```{r}
length(which(ChileYN$vote=="N" & ChileYN$statusquo<=-0))/length(which(ChileYN$statusquo<=-0))*100

```
De hecho el 91% de las personas con un statusquo menor que 0 votan N, podemos por tanto imputar N a las personas que contestaron U o que tienen NA pero su statusquo es menor que 0.

```{r}
summary(Chile$vote)
Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote)) %>% nrow()

```
Hay 701 filas a imputar los datos entre U y NA,  de esos hay que ver los que tengan statusquo menor que 0 para imputarles el voto N

```{r}
Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote),statusquo < 0) %>% nrow()
Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote),statusquo > 0) %>% nrow()
Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote),statusquo == 0) %>% nrow()
```
323 tienen el statusquo menor que 0 y 378 mayor que 0, ninguno es exactamente 0. Vamos a haer los dos indices para imputar los Y y los N.
```{r}
filasN <- Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote),statusquo < 0) %>% rownames()
Chile[filasN,"vote"]<- "N"
filasY <- Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote),statusquo > 0) %>% rownames()
Chile[filasY,"vote"]<- "Y"
```
Vamos a ver como queda la variable vote
```{r}
summary(Chile$vote)
Chiledescriptivo<-Chile
Chiledescriptivo<-droplevels(Chiledescriptivo)
```
1190 N y 1214 Y, según nuestras predicciones este sería el resultado. 

Podriamos comparar ahora nuestro resultado con el obtenido por el algoritmo CART(Clasification and regresion Tree algorithm, rpart en caret) para ello deberemos preparar los datos de nuevo.

```{r}
data(Chile)
Chile<-Chile%>%drop_na(1:7)
Chile<-Chile%>%filter(vote!="A"| is.na(vote))
Chile$vote<-droplevels(Chile$vote)
```
En estos casos habria que mirar si los datos estan balanceados, pero solo debemos fijarnos en los que votan Y o N
```{r}
ChileYN2<-Chile %>% filter(Chile$vote!="U")
table(ChileYN2$vote=="Y")/nrow(ChileYN2) * 100
ChileYN2<-droplevels(ChileYN2)
```
Vemos que los datos estan perfectamente balanceados.
Despues haremos una particion de los datos manteniendo esa estructura.
```{r}
inTrain <- createDataPartition(
  y = ChileYN2$vote,
  p = .75, #porcentaje en el train
  list = FALSE #Devolver en formato vector. 
)
training <- ChileYN2[inTrain,];nrow(training)#1278
testing <- ChileYN2[-inTrain,];nrow(testing)#425
```
Ahora vamos a entrenar el podelo para predecir.
```{r}
rpartmodel <- train(
  vote ~ .,
  data = training, 
  method = "rpart",
)
predict1<-predict(rpartmodel,newdata = testing)
```
Vamos a ver la matriz de confusión
```{r}
cf1<-confusionMatrix(data=predict1,reference=testing$vote)
cf1
```
Tiene un accuracy de 0.91, al igual que nosotros cuando imputamos a partir de un statusquo < 0(Cuando los datos estan balanceados el accuracy), tambien es interesnte observar la matriz de confusión.
```{r}
cf1$table
```
Tengo 12 falsos positivos y 26 falsos negativos. Vamos a ver como funciona el arbol.
```{r}
rattle::fancyRpartPlot(rpartmodel$finalModel)
```
Funciona muy parecido a nuestro análisis descriptivo pero en lugar de elegir el valor 0 elige el 0.022.

Vamos a aplicar este modelo a los datos de Chile, en lugar solo a los de test, paara ello dividiremos los datos de Chile en función de los que tenemos que predecir y los que no
```{r}
Chile1<-Chile %>% filter(vote!="Y" & vote!="N" | is.na(vote))
Chile2<- Chile %>% filter(vote== "Y" | vote=="N")
```
Chile 1 son los datos que vamos a predecir
```{r}
Chile1$vote<-predict(rpartmodel,newdata =Chile1)
Chile1
```
Ahora juntaremos los datos
```{r}
ChileCART<-rbind(Chile1,Chile2)
ChileCART<-droplevels(ChileCART)
```
Vamos a ver como quedan ahora los datos predichos según el algoritmo CART y compararlos con los datos predichos segun el análisis descriptivos
```{r}
summary(ChileCART$vote)
summary(Chiledescriptivo$vote)
```
Vemos que la predicción es muy parecida, prácticamente igual, los algoritmos son herramientas de predicción muy potentes, pero el análisis descriptivo también y es la base para el trabajo de análisis de datos.
